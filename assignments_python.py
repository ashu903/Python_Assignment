# -*- coding: utf-8 -*-
"""Assignments_python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ORZscw4FJie79kIsrVBWvuR4u9lnxZZD
"""

# Question 1.1: Write the Answer to these questions.
# Note: Give at least one example for each off the questions

# What is te difference between static and dynamic variables in Python?
# Ans>>
# Static Variables:
# Definition: In Python, what might be referred to as "static variables" are typically class variables. These are variables that are shared across all instances of a class.
# They are defined within a class but outside of any instance methods.
# Usage: Class variables can be used to store information that is common to all instances of the class. For example, they might be used to keep a count of all instances created.
class MyClass:
    static_variable = 0  # This is a class variable

    def __init__(self, value):
        self.value = value
        MyClass.static_variable += 1

# Accessing class variable
print(MyClass.static_variable)


# Dynamic variable :
# Definition: What might be referred to as "dynamic variables" are typically instance variables in Python. These are variables that are specific to each instance of a class.
# they are usually defined within the __init__ method or other instance methods.
# Usage: Instance variables store data that is unique to each instance of the class. For example, they might be used to store the state of an object.
class MyClass:
    def __init__(self, value):
        self.instance_variable = value  # This is an instance variable

# Creating instances with their own instance variables
obj1 = MyClass(10)
obj2 = MyClass(20)

print(obj1.instance_variable)  # Output: 10
print(obj2.instance_variable)  # Output: 20

# Explain te purpose of "pop","popitem","clear()" in a dictionary with suitable examples.
# Ans>>
# The pop() method removes the specified key and returns the corresponding value. If the key is not found, it can return a default value if provided, otherwise, it raises a KeyError
# syntax : dict.pop(key, default)
my_dict = {'name': 'Alice', 'age': 30, 'city': 'New York'}

# Remove and return the value associated with 'age'
age = my_dict.pop('age')
print(age)  # Output: 30
print(my_dict)  # Output: {'name': 'Alice', 'city': 'New York'}

# Using default value if key not found
gender = my_dict.pop('gender', 'Unknown')
print(gender)  # Output: Unknow

# The popitem() method removes and returns the last inserted key-value pair as a tuple. If the dictionary is empty, it raises a KeyError.
my_dict = {'name': 'Alice', 'age': 30, 'city': 'New York'}

# Remove and return the last inserted item
item = my_dict.popitem()
print(item)  # Output: ('city', 'New York')
print(my_dict)  # Output: {'name': 'Alice', 'age': 30}

# The clear() method removes all items from the dictionary, leaving it empty.
my_dict = {'name': 'Alice', 'age': 30, 'city': 'New York'}

# Clear all items from the dictionary
my_dict.clear()
print(my_dict)  # Output: {}

# What do you mean by FrozenSet? Explain it with suitable examples.
# Ans>.
# In Python, a frozenset is an immutable version of a set. Like a set, a frozenset is an unordered collection of unique elements, but unlike a set,once a frozenset is created
# its elements cannot be modified—meaning you cannot add, remove, or update elements in a frozenset.

# Creating a frozenset from a list
fs1 = frozenset([1, 2, 3, 4])
print(fs1)  # Output: frozenset({1, 2, 3, 4})

# Creating a frozenset from a set
fs2 = frozenset({1, 2, 2, 3})
print(fs2)  # Output: frozenset({1, 2, 3})

# Creating an empty frozenset
fs3 = frozenset()
print(fs3)  # Output: frozenset()

# Differentiate between mutable and immutable data types in Python and give examples of mutable and immutable data types.
# Ans>>
# Mutable Data Types
# Mutable data types are types whose instances can be altered. This means that the data in the object can be changed or updated without creating a new object. Common mutable data types in Python include:
my_list = [1, 2, 3]
my_list.append(4)
my_list[0] = 10

my_list

# Immutable Data Types
# Immutable data types are types whose instances cannot be altered once they are created. Any operation that seems to modify an immutable object will actually create a new object.

my_string = "hello"
new_string = my_string.upper()  # new_string is "HELLO", my_string remains "hello"

new_string

# What is __init__? Explain with an example.
# Ans>>
# The __init__ method in Python is a special method that is automatically called when a new instance of a class is created.
# It is commonly known as a constructor, and it is used to initialize the attributes of the class.
# Example:
class Person:
    def __init__(self, name, age):
        # Initializing instance attributes
        self.name = name
        self.age = age

    def display_info(self):
        print(f"Name: {self.name}, Age: {self.age}")

# Creating instances of the Person class
person1 = Person("Alice", 30)
person2 = Person("Bob", 25)

# Accessing attributes and methods
person1.display_info()  # Output: Name: Alice, Age: 30
person2.display_info()  # Output: Name: Bob, Age: 25

# What is docstring in Python?Explain with an example.
# ans >>
# In Python, a docstring (short for documentation string) is a special kind of string that is used to document a specific segment of code.
# Docstrings are enclosed within triple quotes (""" or ''') and are typically placed at the beginning of modules, classes, functions, or methods.

class Calculator:

    def add(self, a, b):
        return a + b

    def subtract(self, a, b):
        return a - b

# Accessing the docstrings
print(Calculator.__doc__)
print(Calculator.add.__doc__)

# What are unit tests in Python?
# Ans>>
# Unit tests in Python are a type of software testing that involves verifying the correctness of individual units or components of a codebase.
# These units can be functions, methods, or classes. The primary purpose of unit testing is to ensure that each unit of the software performs as expected and to detect any issues early in the development process.
import unittest

# The function to be tested
def add(a, b):
    return a + b

# Unit test class
class TestMathFunctions(unittest.TestCase):

    def test_add(self):
        # Test case 1: Positive numbers
        self.assertEqual(add(2, 3), 5)

        # Test case 2: Negative numbers
        self.assertEqual(add(-1, -1), -2)

        # Test case 3: Mixed numbers
        self.assertEqual(add(-1, 5), 4)

    def test_add_with_zero(self):
        # Test case: Adding zero
        self.assertEqual(add(0, 5), 5)
        self.assertEqual(add(5, 0), 5)

# Running the tests
if __name__ == '__main__':
    # Create a test suite
    suite = unittest.TestLoader().loadTestsFromTestCase(TestMathFunctions)

    # Create a test runner and run the tests
    runner = unittest.TextTestRunner()
    runner.run(suite)  # This will print the test results to the console

# What is break, continue and pass in Pyton?
# Ans>>
# In Python, break, continue, and pass are control flow statements that are used within loops and conditionals to alter the execution flow of the program. Each serves a different purpose:
# 1. break : The break statement is used to terminate the nearest enclosing loop prematurely. When a break statement is encountered, the loop stops executing,
# and control is transferred to the statement immediately following the loop.
# Using break in a loop
for i in range(10):
    if i == 5:
        break  # Loop terminates when i is 5
    print(i)
# Output: 0, 1, 2, 3, 4

# 2.Continue :The continue statement is used to skip the current iteration of the nearest enclosing loop and proceed to the next iteration.
# When continue is encountered, the rest of the code inside the loop for the current iteration is skipped, and the loop proceeds with the next iteration.
# Using continue in a loop
for i in range(10):
    if i % 2 == 0:
        continue  # Skip the rest of the loop body if i is even
    print(i)
# Output: 1, 3, 5, 7, 9

# 3.pass :The pass statement is a no-operation statement that does nothing when executed. It is used as a placeholder in code where a statement is syntactically required but where no action is needed.
#  This can be useful in situations where code is being developed and the programmer hasn't yet written the implementation, or in defining empty classes, functions, or loops.
# Using pass in a loop
for i in range(5):
    if i == 3:
        pass  # Does nothing, serves as a placeholder
    print(i)
# Output: 0, 1, 2, 3, 4

# Using pass in a function definition
def function_placeholder():
    pass  # Placeholder for future code

# Using pass in class definition
class MyClass:
    pass  # Empty class definition

# What is the use of self in Pyton?
# Ans>>
# In Python, self is a conventional name used to refer to the instance of the class in class methods. It is not a keyword in Python but a strong convention.
# The first parameter of any instance method in a class is self, which refers to the object itself when the method is called.
class Dog:
    def __init__(self, name, age):
        self.name = name  # `self.name` is an instance variable
        self.age = age    # `self.age` is another instance variable

    def bark(self):
        return f"{self.name} says woof!"

    def get_age(self):
        return f"{self.name} is {self.age} years old."

# Creating instances of the Dog class
dog1 = Dog("Buddy", 3)
dog2 = Dog("Daisy", 5)

# Accessing methods and attributes using instances
print(dog1.bark())        # Output: Buddy says woof!
print(dog2.get_age())     # Output: Daisy is 5 years old.

# What are global, protected and private attributes in Pyton?
# ans>>
# 1. Global Attributes >> Global attributes are variables that are defined at the top level of a script or module, outside of any class or function.
# They can be accessed and modified from anywhere within the same module or script.
# a. Global variable
global_var = "I am global!"

def access_global():
    print(global_var)

class Example:
    def show_global(self):
        print(global_var)

access_global()  # Output: I am global!
example = Example()
example.show_global()  # Output: I am global!

# b.Protected Attributes:  Protected attributes are intended to be accessible only within their class and subclasses. By convention, these attributes are preceded by a single underscore (_).
# This naming convention indicates that the attribute is intended for internal use and should not be accessed directly from outside the class.
class Base:
    def __init__(self):
        self._protected_var = "I am protected!"

class Derived(Base):
    def access_protected(self):
        return self._protected_var

base = Base()
print(base._protected_var)  # Output: I am protected! (not recommended)

derived = Derived()
print(derived.access_protected())  # Output: I am protected!

# c.Private Attributes : Private attributes are intended to be accessible only within their class. They are denoted by prefixing the attribute name with a double underscore (__).
# This triggers name mangling, where the interpreter changes the name of the attribute to include the class name, making it harder
# This is done to prevent accidental access or modification, but it can still be bypassed if necessary.
class MyClass:
    def __init__(self):
        self.__private_var = "I am private!"

    def get_private(self):
        return self.__private_var

obj = MyClass()
# print(obj.__private_var)  # This will raise an AttributeError

# Accessing the private variable using name mangling
print(obj._MyClass__private_var)  # Output: I am private! (not recommended)

# Proper way to access private attribute
print(obj.get_private())  # Output: I am private!

# What are modules and packages in Pyhton?
# Ans>>
# In Python, modules and packages are organizational tools that help manage code by grouping related functions, classes, and variables together.
# They allow for code reusability, modularity, and better organization, making it easier to maintain and scale Python projects.

# Modules ::
# Modules are individual files containing Python code. A module can contain functions, classes, variables, and runnable code.
# The primary purpose of a module is to group related code into a single file, making it easier to manage and reuse.
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

PI = 3.14159

# Packages ::
# Packages are a way of organizing related modules into directories. A package is a directory that contains multiple modules and a special file named __init__.py.
# This file can be empty or contain initialization code for the package. The __init__.py file indicates that the directory should be treated as a package.

# What are lists and tuples? What is the key difference between the two?
# Ans>>
# Lists and tuples are both sequence data types in Python that are used to store collections of items. They have similar functionalities but also some key differences.
# Lists :Definition: A list is a mutable sequence, meaning its elements can be changed after the list has been created. Lists are created using square brackets ([]).
my_list = [1, 2, 3, 'hello', 4.5]
my_list

# Tuples: Definition: A tuple is an immutable sequence, meaning its elements cannot be changed after the tuple has been created. Tuples are created using parentheses (()).
my_tuple = (1, 2, 3, 'hello', 4.5)

my_tuple

my_list

my_tuple

# What is an Interpreted language & dynamically typed language?Write 5 dierences between them.
# Ans>> Interpreted Language:
# An interpreted language is a programming language in which most of the instructions are executed directly by an interpreter, rather than being compiled into machine code
# The interpreter reads and executes the code line by line or statement by statement.

# Characteristics:
# Execution: Code is executed directly by the interpreter without the need for a separate compilation step.
# Error Detection: Errors are typically detected at runtime.
# Development Cycle: Faster development cycle due to immediate feedback from running code.
# Portability: Highly portable, as the interpreter can be implemented on different platforms.
# Examples: Python, Ruby, JavaScript.

# Dynamically Typed Language: A dynamically typed language is a programming language in which types are checked at runtime rather than at compile-time.
# This means that variables do not have a fixed type and can hold values of different types during execution.
# Characteristics:
# Type Checking: Types are determined at runtime, and type errors are only caught when the code is executed.
# Flexibility: Variables can be reassigned to values of different types.
# Error Detection: Type-related errors are detected during runtime.
# Development Speed: Can lead to faster development as type information is not required at compile time.

# Key Differences Between Interpreted Languages and Dynamically Typed Languages
# 1. Definition:
'''Interpreted Language: Refers to the way code is executed by an interpreter.
 Dynamically Typed Language: Refers to how types are handled and checked during execution.'''

# 2.Execution:
''' Interpreted Language: Executes code line by line or statement by statement.
Dynamically Typed Language: Execution does not inherently depend on whether the language is interpreted or compiled; it focuses on type handling.'''

# 3.Type Checking:
'''Interpreted Language: Type checking can be either dynamic or static, depending on the language.
Dynamically Typed Language: Type checking is dynamic, occurring at runtime.'''

# 4.Compilation:
''' Interpreted Language: Does not require a separate compilation step; code is executed directly by the interpreter.
Dynamically Typed Language: Can be either interpreted or compiled, but its dynamic type system remains the same regardless of the execution method.'''

# 5.Error Handling:
''' Interpreted Language: Errors are detected and reported during runtime as the interpreter processes the code.
Dynamically Typed Language: Type-related errors are also detected at runtime, but the language’s dynamic nature means type errors are a specific category of runtime errors.'''

# What are Dict and List compreensions?
# Ans>> Dictionary (dict) comprehensions and list comprehensions are concise ways to create dictionaries and lists in Python.
# They provide a more readable and compact syntax for creating these data structures compared to traditional methods using loops.

# List Comprehensions:
# A list comprehension provides a compact way to create lists. The syntax is [expression for item in iterable if condition], where:
# expression is the value to be included in the new list.item represents each element in the iterable (e.g., list, range).
# condition is optional and filters the elements to be included based on a Boolean expression.
# Creating a list of squares of numbers from 0 to 4
squares = [x ** 2 for x in range(5)]
print(squares)  # Output: [0, 1, 4, 9, 16]


# Dictionary Comprehensions:
# A dictionary comprehension allows you to create dictionaries in a similar manner to list comprehensions. The syntax is {key_expression: value_expression for item in iterable if condition} where:
# key_expression is the key for the dictionary.
# value_expression is the value associated with the key.
# item represents each element in the iterable.
# condition is optional and filters which items are included in the dictionary.

# Creating a dictionary with numbers as keys and their squares as values
squares_dict = {x: x ** 2 for x in range(5)}
print(squares_dict)  # Output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# Q.What are decorators in Python? Explain it with an example.Write down its use cases.
# Ans>>
# Decorators in Python are a powerful and flexible way to modify or extend the behavior of functions or methods without permanently modifying their source code.
# They are essentially functions that wrap another function or method, allowing you to add functionality before or after the wrapped function is called.
# Example:
def log_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"Function '{func.__name__}' called with args: {args} and kwargs: {kwargs}")
        return func(*args, **kwargs)
    return wrapper

@log_decorator
def add(a, b):
    return a + b

result = add(3, 5)
print(result)


# Use Cases for Decorators:
# Logging: Automatically log information about function calls, which is useful for debugging and monitoring.
# Authentication: Check if a user has the necessary permissions to execute a function.
# Timing: Measure the time a function takes to execute, which can be useful for performance analysis.
# Caching: Cache the results of expensive function calls and return the cached result when the same inputs occur agai
# Validation: Validate the inputs to a function before executing it, ensuring that they meet certain criteria.

# Q.How is memory managed in Python?
# Ans>> Memory management in Python involves the allocation and deallocation of memory to store data objects. Python uses a combination of techniques to manage memory efficiently, including
# automatic garbage collection, reference counting, and memory pooling. Here's a brief overview of how these mechanisms work:
#1.Reference Counting
#2.Garbage Collection
#3.Memory Pools and Arenas
#4.Object-Specific Allocators

# Q.What is lambda in Python? Why is it used?
# Ans>>
# In Python, a lambda is a way to create small, anonymous functions—functions without a name—using a special syntax. These functions are often used for short, simple operations and are defined using the lambda keyword.
add = lambda x, y: x + y
print(add(2, 3))  # Output: 5

# Use Cases for lambda Functions:
# Simplicity: Lambda functions are used for simple, short functions where using a full def statement would be unnecessarily verbose
# Higher-Order Functions: Lambda functions are often used in conjunction with higher-order functions like map(), filter(), and reduce(), where a function is applied to elements in a list or iterable.

# Q.Explain split() and join() functions in Pyhton?
# Ans>>
# In Python, split() and join() are two commonly used string methods that facilitate the manipulation of strings.

# split() Method:
# The split() method is used to divide a string into a list of substrings based on a specified delimiter (separator). If no delimiter is provided, the method uses whitespace (space, newline, tab, etc.) as the default delimiter.
text = "Python is fun"
words = text.split()
print(words)  # Output: ['Python', 'is', 'fun']

data = "apple,orange,banana,grape"
fruits = data.split(",")
print(fruits)  # Output: ['apple', 'orange', 'banana', 'grape']

text = "one:two:three:four"
parts = text.split(":", maxsplit=2)
print(parts)  # Output: ['one', 'two', 'three:four']


# join() Method:The join() method is used to concatenate a list (or any iterable) of strings into a single string, with each element separated by a specified delimiter.
words = ['Python', 'is', 'fun']
sentence = " ".join(words)
print(sentence)  # Output: 'Python is fun'

fruits = ['apple', 'orange', 'banana', 'grape']
result = ",".join(fruits)
print(result)  # Output: 'apple,orange,banana,grape'

# Q.What are iterators , iterable & generators in Python?
# Ans>>
# 1. Iterables:An iterable is any Python object that can return its members one at a time, allowing it to be looped over in a for loop. Common examples of iterables include
# lists, tuples, strings, dictionaries, and sets. In Python, an object is considered iterable if it implements the __iter__() method, which returns an iterator.
my_list = [1, 2, 3, 4, 5]
for item in my_list:
    print(item)

# 2. Iterators :An iterator is an object that represents a stream of data; it returns the data one element at a time when called repeatedly. Iterators implement two key methods:
# __iter__(): Returns the iterator object itself, typically self. This method allows the object to be used in for loops and other places where an iterable is required.
# __next__(): Returns the next item from the iterator. When there are no more items to return, it raises the StopIteration exception.
my_list = [1, 2, 3]
iterator = iter(my_list)  # Obtain an iterator from an iterable

print(next(iterator))  # Output: 1
print(next(iterator))  # Output: 2
print(next(iterator))  # Output: 3
# next(iterator) would raise StopIteration here, as there are no more items

# 3. Generators:Generators are a special type of iterator that allow you to iterate over data without storing the entire sequence in memory at once.
# They are defined using a function, but instead of returning a single value, a generator function yields a series of values using the yield statement. Each call to yield
# produces a value, and the state of the generator function is preserved between calls, so that execution can be resumed later.
# Generator Functions: Use the yield statement.
# Generator Expressions: Similar to list comprehensions, but use parentheses instead of square brackets.
def count_up_to(max):
    count = 1
    while count <= max:
        yield count
        count += 1

counter = count_up_to(5)
for number in counter:
    print(number)
# Output: 1, 2, 3, 4, 5

# Q.What is the difference between xrange and range in Python?
# Ans>>
# In Python, range and xrange are functions that generate a sequence of numbers. However, they have some important differences, particularly between Python 2 and Python 3.
# Python 2 range: Creates a list of numbers in memory.
# Python 2 xrange: Creates an iterable that generates numbers on-the-fly, without storing them in memory.
# Python 3 range: Combines the benefits of xrange in Python 2, generating numbers on-the-fly without creating a list in memory. xrange is no longer available in Python 3.
numbers = range(1, 1000000)
# numbers is a list of numbers from 1 to 999999

# Q.Pillars of Oops?
# Ans>> Object-Oriented Programming (OOP) is a programming paradigm based on the concept of "objects," which can contain data in the form of fields
# (attributes or properties) and code in the form of procedures (methods). The four fundamental pillars of OOP are:
# 1.Encapsulation:Encapsulation is the practice of bundling the data (attributes) and the methods (functions) that manipulate the data into a single unit, known as an object
# 2.Inheritance:Inheritance allows a class to inherit attributes and methods from another class. This promotes code reuse and establishes a natural hierarchy between classes.
# 3.Polymorphism:Polymorphism allows objects of different classes to be treated as objects of a common super class. It is often used in reference to the ability of different classes to respond to the same message
# 4.Abstraction:Abstraction is the concept of hiding the complex implementation details and showing only the essential features of an object. It helps in reducing programming complexity and effort.

# Q.How will you check if a class is a child of another class?
# Ans>> In Python, you can check if a class is a subclass of another class using the built-in issubclass() function or the isinstance() function if you want to check if an instance belongs to a subclass.
# 1. Using issubclass():
# The issubclass() function checks if a class is a subclass of another class. It returns True if the first argument is indeed a subclass of the second argument, otherwise, it returns False.
class Animal:
    pass

class Dog(Animal):
    pass

print(issubclass(Dog, Animal))  # Output: True
print(issubclass(Dog, object))  # Output: True, since all classes in Python inherit from object
print(issubclass(Animal, Dog))  # Output: False


# 2.Using isinstance():the isinstance() function is used to check if an object is an instance or subclass instance of a class or a tuple of classes.
class Animal:
    pass

class Dog(Animal):
    pass

my_dog = Dog()

print(isinstance(my_dog, Dog))     # Output: True
print(isinstance(my_dog, Animal))  # Output: True, Dog is a subclass of Animal
print(isinstance(my_dog, object))  # Output: True, all objects are instances of the object class

# Q.How does inheritance work in python? Explain all types of inheritance with an example.
# Ans>> Inheritance in Python is a mechanism that allows a new class, called a child class or subclass, to inherit attributes and methods from an existing class, known as a parent class or superclass
# This promotes code reuse and the creation of hierarchical relationships between classes.
#  1.Single Inheritance:Single inheritance involves a child class inheriting from a single parent class. This is the simplest form of inheritance.
class Animal:
    def sound(self):
        return "Some sound"

class Dog(Animal):
    def bark(self):
        return "Woof!"

# Using the subclass
dog = Dog()
print(dog.sound())  # Inherited method
print(dog.bark())   # Subclass's own method

# 2.Multiple Inheritance:In multiple inheritance, a child class inherits from more than one parent class. This allows the child class to access attributes and methods from all parent classes
class Canine:
    def canine_trait(self):
        return "Canine trait"

class Mammal:
    def mammal_trait(self):
        return "Mammal trait"

class Dog(Canine, Mammal):
    def bark(self):
        return "Woof!"

# Using the subclass
dog = Dog()
print(dog.canine_trait())  # From Canine
print(dog.mammal_trait())  # From Mammal
print(dog.bark())          # Own method

# 3.Multilevel Inheritance:Multilevel inheritance occurs when a child class inherits from another child class, creating a chain of inheritance.
class Animal:
    def sound(self):
        return "Some sound"

class Mammal(Animal):
    def has_fur(self):
        return True

class Dog(Mammal):
    def bark(self):
        return "Woof!"

# Using the subclass
dog = Dog()
print(dog.sound())  # From Animal
print(dog.has_fur())  # From Mammal
print(dog.bark())     # From Dog

# 4.Hierarchical Inheritance:Hierarchical inheritance occurs when multiple child classes inherit from a single parent class.
class Animal:
    def sound(self):
        return "Some sound"

class Dog(Animal):
    def bark(self):
        return "Woof!"

class Cat(Animal):
    def meow(self):
        return "Meow!"

# Using the subclasses
dog = Dog()
cat = Cat()
print(dog.sound())  # Inherited from Animal
print(dog.bark())   # Own method

print(cat.sound())  # Inherited from Animal
print(cat.meow())   # Own method


# 5.Hybrid Inheritance:Hybrid inheritance is a combination of two or more types of inheritance. It can be a complex form of inheritance involving multiple and multilevel inheritance.
class Animal:
    def sound(self):
        return "Some sound"

class Mammal(Animal):
    def has_fur(self):
        return True

class Canine:
    def canine_trait(self):
        return "Canine trait"

class Dog(Mammal, Canine):
    def bark(self):
        return "Woof!"

# Using the subclass
dog = Dog()
print(dog.sound())  # From Animal
print(dog.has_fur())  # From Mammal
print(dog.canine_trait())  # From Canine
print(dog.bark())     # From Dog

# Q.What is encapsulation? Explain it with an example?
# Ans>>
# Encapsulation is one of the fundamental principles of object-oriented programming (OOP). It refers to the bundling of data (attributes) and the methods (functions) that operate on that data into a
# single unit called an object. Encapsulation also involves restricting access to certain components of an object to protect the internal state and prevent unintended interference and misuse.

# Key Aspects of Encapsulation:
# data Hiding: Encapsulation allows for the internal representation of an object to be hidden from the outside.
# Interface and Implementation Separation: By restricting access to the internal workings of an object, encapsulation separates the interface (what the object can do) from the implementation
class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.__balance = balance  # Private attribute

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
        else:
            print("Deposit amount must be positive")

    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
        else:
            print("Invalid withdrawal amount")

    def get_balance(self):
        return self.__balance

# Usage
account = BankAccount("Alice", 1000)
account.deposit(500)
print(account.get_balance())  # Output: 1500

account.withdraw(200)
print(account.get_balance())  # Output: 1300

# Attempt to access the private attribute directly (not recommended)
# print(account.__balance)  # AttributeError: 'BankAccount' object has no attribute '__balance'

# What is polymorpism? Explain it with an example.
# Ans>> Polymorphism is a fundamental concept in object-oriented programming (OOP) that allows objects of different classes to be treated as objects of a common superclass
# It enables a single interface to represent different underlying forms (data types). In simpler terms, polymorphism allows different
# classes to implement methods that have the same name but behave differently based on the object's class.

# Types of Polymorphism: Method Overriding (Runtime Polymorphism) , Method Overloading (Compile-time Polymorphism) , Operator Overloading

class Animal:
    def make_sound(self):
        return "Some generic sound"

class Dog(Animal):
    def make_sound(self):
        return "Woof!"

class Cat(Animal):
    def make_sound(self):
        return "Meow!"

# Function that uses polymorphism
def animal_sound(animal):
    print(animal.make_sound())

# Using polymorphism
dog = Dog()
cat = Cat()

animal_sound(dog)  # Output: Woof!
animal_sound(cat)  # Output: Meow!

# Q 1.2 Which of the following identifier names are invalid and why?
# a) Serial_no. >> Invalid: Identifiers cannot contain special characters such as dots (.).
# b) 1st_Room  >>
# c) Hundred$
# d) Total_Marks
# e) total-Marks
# f) Total Marks
# g) True
# h) _Percentag

# Ans>>

# Rules for Valid Identifiers
# 1.Must start with a letter (a-z, A-Z) or an underscore (_).
# 2.Subsequent characters can be letters, digits (0-9), or underscores.
# 3.Cannot start with a digit.
# 4.Cannot be a reserved keyword (e.g., True, False, None).

# a> Invalid: Identifiers cannot contain special characters such as dots (.)
# b> Invalid: Identifiers cannot start with a digit. It should start with a letter or an underscore.
# c> Invalid: Identifiers cannot contain special characters like the dollar sign ($).
# d> Valid: This identifier starts with a letter and contains only letters and underscores, which are allowed.
# e> Invalid: Identifiers cannot contain hyphens (-). Use underscores (_) instead.
# f> Invalid: Identifiers cannot contain spaces.
# g> Invalid: True is a reserved keyword in Python and cannot be used as an identifier.
# h> Valid: This identifier starts with an underscore and contains only letters and underscores, which are allowed. (Assuming it’s not a typo and should be _Percentage.)

# Question 1.3
# name = ["Mohan", "dash", "karam", "chandra","gandhi","Bapu"]
# do the following operations in this list;
# a) add an element "freedom_fighter" in this list at the 0th index.
# b) find the output of the following ,and explain how?
# name = [“freedomFighter”,"Bapuji","MOhan" "dash", "karam",
# "chandra","gandhi"]
# length1=len((name[-len(name)+1:-1:2]))
# length2=len((name[-len(name)+1:-1]))
# print(length1+length2)

# c) add two more elements in the name ["NetaJi","Bose"] at the end of the list.
# d) what will be the value of temp:
# name = ["Bapuji", "dash", "karam", "chandra","gandi","Mohan"]
# temp=name[-1]
# name[-1]=name[0]
# name[0]=temp
# print(name)

# Ans>>
# a >>
name = ["Mohan", "dash", "karam", "chandra", "gandhi", "Bapu"]
name.insert(0, "freedom_fighter")
print(name)

# b>>
name = ["freedomFighter", "Bapuji", "MOhan", "dash", "karam", "chandra", "gandhi"]
length1 = len(name[-len(name)+1:-1:2])
length2 = len(name[-len(name)+1:-1])
print(length1 + length2)

length1 = len(name[-len(name)+1:-1:2])
length2 = len(name[-len(name)+1:-1])
print(length1 + length2)


# C>>
name.append("NetaJi")
name.append("Bose")
print(name)

# D>>

['freedomFighter', 'Bapuji', 'MOhan', 'dash', 'karam', 'chandra', 'gandhi', 'NetaJi', 'Bose']
name = ["Bapuji", "dash", "karam", "chandra", "gandi", "Mohan"]
temp = name[-1]
name[-1] = name[0]
name[0] = temp
print(name)

# Question 1.4.Find the output of the following.
# animal = ['Human','cat','mat','cat','rat','Human', 'Lion']
# print(animal.count('Human'))
# print(animal.index('rat'))
# print(len(animal))

# Ans >>
animal = ['Human', 'cat', 'mat', 'cat', 'rat', 'Human', 'Lion']
print(animal.count('Human'))
print(animal.index('rat'))
print(len(animal))

# Question 1.5. tuple1=(10,20,"Apple",3.4,'a',["master","ji"],("sita","geeta",22),[{"roll_no":1},{"name":"Navneet"}])
# a)print(len(tuple1))
# b)print(tuple1[-1][-1]["name"])
# c)fetch the value of roll_no from this tuple.
# d)print(tuple1[-3][1])
# e)fetch the element "22" from this tuple

# Ans>>
tuple1=(10,20,"Apple",3.4,'a',["master","ji"],("sita","geeta",22),[{"roll_no":1},{"name":"Navneet"}])
# a>>

print(len(tuple1))

# b>>

print(tuple1[-1][-1]["name"])

# c>>

roll_no = tuple1[-1][0]["roll_no"]
print(roll_no)

# d>>

print(tuple1[-3][1])

# e>>

element = tuple1[-2][2]
print(element)

#Q 1.6. Write a program to display the appropriate message as per the color of signal(RED-Stop/Yellow-Stay/Green-Go) at the road crossing.
# Ans>>
def display_signal_message(color):
    if color.lower() == 'red':
        return "Stop"
    elif color.lower() == 'yellow':
        return "Stay"
    elif color.lower() == 'green':
        return "Go"
    else:
        return "Invalid color! Please enter RED, YELLOW, or GREEN."

# Example usage
signal_color = input("Enter the color of the signal (RED, YELLOW, GREEN): ")
message = display_signal_message(signal_color)
print(message)

#Q1.7 Write a program to create a simple calculator performing only four basic operations(+,-,/,*) .
# Ans>>
def add(x, y):
    return x + y

def subtract(x, y):
    return x - y

def multiply(x, y):
    return x * y

def divide(x, y):
    if y == 0:
        return "Error! Division by zero."
    return x / y

def main():
    print("Select operation:")
    print("1. Add")
    print("2. Subtract")
    print("3. Multiply")
    print("4. Divide")

    choice = input("Enter choice (1/2/3/4): ")

    if choice in ['1', '2', '3', '4']:
        num1 = float(input("Enter first number: "))
        num2 = float(input("Enter second number: "))

        if choice == '1':
            print(f"{num1} + {num2} = {add(num1, num2)}")
        elif choice == '2':
            print(f"{num1} - {num2} = {subtract(num1, num2)}")
        elif choice == '3':
            print(f"{num1} * {num2} = {multiply(num1, num2)}")
        elif choice == '4':
            print(f"{num1} / {num2} = {divide(num1, num2)}")
    else:
        print("Invalid input! Please select a valid operation.")

if __name__ == "__main__":
    main()

# Q 1.8 Write a program to find the larger of the three pre-specified numbers using ternary operators.
# Ans>>
a = 10
b = 20
c = 15
largest = a if (a > b and a > c) else (b if b > c else c)

print(f"The largest number among {a}, {b}, and {c} is {largest}.")

99# Q 1.9. Write a program to find the factors of a whole number using a while loop.
# Ans>>
def find_factors(number):
    factors = []
    i = 1
    while i <= number:
        if number % i == 0:
            factors.append(i)
        i += 1
    return factors

def main():
    try:
        num = int(input("Enter a whole number: "))
        if num < 0:
            print("Please enter a non-negative whole number.")
        else:
            factors = find_factors(num)
            print(f"The factors of {num} are: {factors}")
    except ValueError:
        print("Invalid input! Please enter a valid integer.")

if __name__ == "__main__":
    main()

# Q 1.10. Write a program to find the sum of all the positive numbers entered by the user. As soon as the user.
# enters a negative number, stop taking in any further input from the user and display the sum .
# Ans>>
def main():
    total_sum = 0

    while True:
        try:
            number = float(input("Enter a positive number (or a negative number to stop): "))
            if number < 0:
                break
            total_sum += number
        except ValueError:
            print("Invalid input! Please enter a numeric value.")

    print(f"The sum of all positive numbers entered is: {total_sum}")

if __name__ == "__main__":
    main()

# Q 1.11 Write a program to find prime numbers between 2 to 100 using nested for loops.
def is_prime(number):
    # A prime number is greater than 1 and has no divisors other than 1 and itself.
    if number <= 1:
        return False
    for i in range(2, int(number**0.5) + 1):
        if number % i == 0:
            return False
    return True

def find_primes(start, end):
    prime_numbers = []
    for num in range(start, end + 1):
        if is_prime(num):
            prime_numbers.append(num)
    return prime_numbers

def main():
    start = 2
    end = 100
    primes = find_primes(start, end)
    print(f"Prime numbers between {start} and {end} are: {primes}")

if __name__ == "__main__":
    main()

#Q 1.12. Write the programs for the following:
# Accept the marks of the student in five major subjects and display the same?
# Calculate the sum of the marks of all subjects.Divide the total marks by number of subjects (i.e. 5), calculate
# percentage = total marks/5 and display the percentage?
# Find the grade of the student as per the following criteria . Hint: Use Match & case for this.:
# criteria                                 Grade
# percentage > 85                            A
# percentage < 85 && percentage >= 75        B
# percentage < 75 && percentage >= 50        C
# percentage < 30 && percentage <= 50        D
# percentage < 30

# Ans>>
# Accepting marks for five subjects
subject1 = int(input("Enter marks for Subject 1: "))
subject2 = int(input("Enter marks for Subject 2: "))
subject3 = int(input("Enter marks for Subject 3: "))
subject4 = int(input("Enter marks for Subject 4: "))
subject5 = int(input("Enter marks for Subject 5: "))

# Displaying the marks
print(f"Marks: Subject 1 = {subject1}, Subject 2 = {subject2}, Subject 3 = {subject3}, Subject 4 = {subject4}, Subject 5 = {subject5}")

# Calculating total marks and percentage
total_marks = subject1 + subject2 + subject3 + subject4 + subject5
percentage = total_marks / 5

# Displaying total marks and percentage
print(f"Total Marks: {total_marks}")
print(f"Percentage: {percentage:.2f}%")

# Determining the grade using match-case
def get_grade(percentage):
    match percentage:
        case p if p > 85:
            return 'A'
        case p if p >= 75 and p <= 85:
            return 'B'
        case p if p >= 50 and p < 75:
            return 'C'
        case p if p >= 30 and p < 50:
            return 'D'
        case _:
            return 'F'

# Getting the grade
grade = get_grade(percentage)

# Displaying the grade
print(f"Grade: {grade}")

# Q 1.13. Write a program for VIBGYOR Spectrum based on their Wavelength using Wavelength Range:
# COLOR        WAVELENGTH(nm)
# violet       400.0 - 440.0
# indigo       440.0 - 460.0
# blue         460.0 - 500.0
# green        500.0 - 570.0
# yellow       570.0 - 590.0
# orange       590.0 - 620.0
# red          620.0 - 720.0

# Ans>>
# Function to determine color based on wavelength
def determine_color(wavelength):
    match wavelength:
        case w if 400.0 <= w < 440.0:
            return "Violet"
        case w if 440.0 <= w < 460.0:
            return "Indigo"
        case w if 460.0 <= w < 500.0:
            return "Blue"
        case w if 500.0 <= w < 570.0:
            return "Green"
        case w if 570.0 <= w < 590.0:
            return "Yellow"
        case w if 590.0 <= w < 620.0:
            return "Orange"
        case w if 620.0 <= w <= 720.0:
            return "Red"
        case _:
            return "Wavelength not in visible spectrum range"

# Input: Wavelength in nanometers
wavelength = float(input("Enter the wavelength in nanometers (nm): "))

# Determine and display the color
color = determine_color(wavelength)
print(f"The color corresponding to wavelength {wavelength} nm is {color}.")

# Q. 1.14.Consider the gravitational interactions between the Earth, Moon, and Sun in our solar system.
# '''Given:
# mass_earth = 5A972e24 # Mass of Earth in kilograms
# mass_moon = 7A347 7309e22 # Mass of Moon in kilograms
# mass_sun = 1A989e30 # Mass of Sun in kilograms
# distance_earth_sun = 1A49 e11 # Average distance between Earth and Sun in meters
# distance_moon_earth = 3A844e8 # Average distance between Moon and Earth in meters
# Tasks:
# * Calculate the gravitational force between the Earth and the Sun.
# * Calculate the gravitational force between the Moon and the Earth.
# * Compare the calculated forces to determine which gravitational force is stronger.
# * Explain which celestial body (Earth or Moon) is more attracted to the other based on the comparison.'''

# Ans>> given data:
# Mass of Earth (mₑ):5.972*10^24 kg
# Mass of Moon (mₘ): 7.347*10^22 kg
# Mass of Sun (mₛ):  1.989*10^30 kg
# Distance between Earth and Sun (dₑₛ): 1.496*10^11 m
# Distance between Moon and Earth (dₘₑ):3.844*10^8 m

# Gravitational Force Formula:
# F = G*m1*m2/r^2

# 1.Gravitational Force between Earth and Sun:3.54*10^22 N
# 2.Gravitational Force between Moon and Earth:1.98*10^20 N
# 3.Comparison of Forces: The gravitational force between the Earth and the Sun is significantly stronger than the gravitational force between the Moon and the Earth
# 4.The Earth is much more strongly attracted to the Sun than the Moon is to the Earth due to the massive difference in the mass of the Sun compared to the Earth and Moon, despite the larger distance.

# Q.2. Design and implement a Python program for managing student information using object-oriented
# principles. Create a class called `Student` with encapsulated attributes for name, age, and roll number.
# Implement getter and setter methods for these attributes. Additionally, provide methods to display student
# information and update student details.
# Task:
# Define the `Student` class with encapsulated attributes.
# Implement getter and setter methods for the attributes.
# Write methods to display student inform7tion and upd7te det7ils.
# Create instances of the `Student` class and test the implemented functionality.


# Ans>>
class Student:
    def __init__(self, name, age, roll_number):
        self.__name = name
        self.__age = age
        self.__roll_number = roll_number


    def get_name(self):
        return self.__name

    def set_name(self, name):
        self.__name = name


    def get_age(self):
        return self.__age

    def set_age(self, age):
        if age > 0:
            self.__age = age
        else:
            print("Please enter a valid age.")


    def get_roll_number(self):
        return self.__roll_number


    def set_roll_number(self, roll_number):
        self.__roll_number = roll_number


    def display_info(self):
        print(f"Name: {self.__name}")
        print(f"Age: {self.__age}")
        print(f"Roll Number: {self.__roll_number}")

    def update_details(self, name=None, age=None, roll_number=None):
        if name is not None:
            self.set_name(name)
        if age is not None:
            self.set_age(age)
        if roll_number is not None:
            self.set_roll_number(roll_number)
        print("Student details updated successfully.")

# Creating instances of the Student class and testing functionality
student1 = Student("Alice", 20, "R001")
student2 = Student("Bob", 22, "R002")

# Displaying initial student information
print("Initial Student Information:")
student1.display_info()
print()
student2.display_info()
print()

# Updating student details
student1.update_details(name="Alice Smith", age=21)
student2.update_details(roll_number="R002X")

# Displaying updated student information
print("\nUpdated Student Information:")
student1.display_info()
print()
student2.display_info()

# Q3.3.Develop a Python program for managing library resources efficiently. Design a class named `LibraryBook`
# with attributes like book name, author, and availability status. Implement methods for borrowing and
# returning books while ensuring proper encapsulation of attributes.
# task:

# 3 1. Create the `LibraryBook` class with encapsulated attributes.
# 2. Implement methods for borrowing and returning books.
# 3. Ensure proper encapsulation to protect book details.
# 4. Test the borrowing and returning functionality with sample data.

# Ans>>
class LibraryBook:
    def __init__(self, book_name, author):
        self.__book_name = book_name
        self.__author = author
        self.__is_available = True

    # Getter for book name
    def get_book_name(self):
        return self.__book_name

    # Getter for author
    def get_author(self):
        return self.__author

    # Getter for availability status
    def is_available(self):
        return self.__is_available

    # Method to borrow a book
    def borrow_book(self):
        if self.__is_available:
            self.__is_available = False
            print(f"You have borrowed '{self.__book_name}' by {self.__author}.")
        else:
            print(f"Sorry, '{self.__book_name}' is currently not available.")

    # Method to return a book
    def return_book(self):
        if not self.__is_available:
            self.__is_available = True
            print(f"'{self.__book_name}' has been returned. Thank you!")
        else:
            print(f"'{self.__book_name}' is already available in the library.")

# Testing the functionality with sample data
book1 = LibraryBook("1984", "George Orwell")
book2 = LibraryBook("To Kill a Mockingbird", "Harper Lee")

# Display initial availability status
print(f"Is '{book1.get_book_name()}' available? {'Yes' if book1.is_available() else 'No'}")
print(f"Is '{book2.get_book_name()}' available? {'Yes' if book2.is_available() else 'No'}")
print()

# Borrowing and returning books
book1.borrow_book()
book1.borrow_book()
book1.return_book()
book1.return_book()
print()

# Borrowing book2
book2.borrow_book()

# Q 4.4.Create a simple banking system using object-oriented concepts in Python. Design classes representing
# different types of bank accounts such as savings and checking. Implement methods for deposit, withdraw,
# and balance inquiry. Utilize inheritance to manage different account types efficiently.
# Task:
# 1. Define base clas(es) for bank accounts with common attributes and methods.
# 2. Implement subclasses for specific account types (e.g., SavingsAccount, CheckingAccount).
# 3. Provide methods for deposit, withdraw, 7nd balance inquiry in each subclass.
# 4. Test the banking system by creating instances of different account types and performing transactions.

# Ans>>
# Base class for bank accounts
class BankAccount:
    def __init__(self, account_number, balance=0):
        self.account_number = account_number
        self.balance = balance

    def deposit(self, amount):
        if amount > 0:
            self.balance += amount
            print(f"Deposited {amount}. New balance is {self.balance}.")
        else:
            print("Deposit amount must be positive.")

    def withdraw(self, amount):
        if amount > 0 and amount <= self.balance:
            self.balance -= amount
            print(f"Withdrew {amount}. New balance is {self.balance}.")
        else:
            print("Invalid withdraw amount or insufficient funds.")

    def inquire_balance(self):
        print(f"The balance for account {self.account_number} is {self.balance}.")
        return self.balance

# Subclass for Savings Account
class SavingsAccount(BankAccount):
    def __init__(self, account_number, balance=0, interest_rate=0.01):
        super().__init__(account_number, balance)
        self.interest_rate = interest_rate

    def add_interest(self):
        interest = self.balance * self.interest_rate
        self.balance += interest
        print(f"Interest of {interest} added. New balance is {self.balance}.")

# Subclass for Checking Account
class CheckingAccount(BankAccount):
    def __init__(self, account_number, balance=0):
        super().__init__(account_number, balance)
        self.overdraft_limit = -500  # Overdraft limit set to -500

    def withdraw(self, amount):
        if amount > 0 and (self.balance - amount) >= self.overdraft_limit:
            self.balance -= amount
            print(f"Withdrew {amount}. New balance is {self.balance}.")
        else:
            print("Overdraft limit reached or invalid amount.")

# Testing the system
# Create a savings account
savings = SavingsAccount("SA123", balance=1000, interest_rate=0.03)
savings.deposit(500)
savings.add_interest()
savings.withdraw(200)
savings.inquire_balance()

# Create a checking account
checking = CheckingAccount("CA456", balance=500)
checking.deposit(100)
checking.withdraw(700)  # Should allow as it's within overdraft limit
checking.withdraw(100)  # Should fail as it exceeds overdraft limit
checking.inquire_balance()

# Q.5 5.Write a Python program that models different animals and their sounds. Design a base class called
# 'Animal` with a method `make_sound()`. Create subclasses like `Dog` and `Cat` that override the
# `make_sound()` method to produce appropriate sounds.
# Tasks:
# 1. Define the `Animal` class with a method `make_sound()`.
# 2. Create subclasses `Dog` and `Cat` that override the `make_sound()` method.
# 3. Implement the sound generation logic for each subclass.
# 4. Test the program by creating instances of `Dog` and `Cat` and calling the `make_sound()` method.

# Ans>>
# Base class for animals
class Animal:
    def make_sound(self):
        pass  # This method will be overridden by subclasses

# Subclass for Dog
class Dog(Animal):
    def make_sound(self):
        return "Woof! Woof!"

# Subclass for Cat
class Cat(Animal):
    def make_sound(self):
        return "Meow!"

dog = Dog()
print(f"The dog says: {dog.make_sound()}")

# Create an instance of Cat and call make_sound
cat = Cat()
print(f"The cat says: {cat.make_sound()}")

# Q.6.Write a code for Restaurant Management System Using OOPS:
# Create a Menultem class that has attributes such as name, description, price, and category.
# Implement methods to add a new menu item, update menu item information, and remove a menu item from the menu.
# Use encapsulation to hide the menu item's unique identification number.
# Inherit from the Menultem class to creat, a Fooditem class and a BeverageItem class, each with their own specific attributes and methods.

# Ans>>

# Base class for menu items
class MenuItem:
    _next_id = 1  # Class variable to keep track of the next ID

    def __init__(self, name, description, price, category):
        self.__id = MenuItem._next_id
        MenuItem._next_id += 1
        self.name = name
        self.description = description
        self.price = price
        self.category = category

    def get_id(self):
        return self.__id

    def add_item(self):
        print(f"Item '{self.name}' added with ID {self.__id}.")

    def update_item(self, name=None, description=None, price=None, category=None):
        if name:
            self.name = name
        if description:
            self.description = description
        if price:
            self.price = price
        if category:
            self.category = category
        print(f"Item '{self.__id}' updated.")

    def remove_item(self):
        print(f"Item '{self.name}' with ID {self.__id} removed.")

# Subclass for food items
class FoodItem(MenuItem):
    def __init__(self, name, description, price, category, is_vegan=False):
        super().__init__(name, description, price, category)
        self.is_vegan = is_vegan

    def update_item(self, is_vegan=None, **kwargs):
        super().update_item(**kwargs)
        if is_vegan is not None:
            self.is_vegan = is_vegan

# Subclass for beverage items
class BeverageItem(MenuItem):
    def __init__(self, name, description, price, category, size="Medium"):
        super().__init__(name, description, price, category)
        self.size = size

    def update_item(self, size=None, **kwargs):
        super().update_item(**kwargs)
        if size:
            self.size = size

# Testing the system
# Create a food item
pizza = FoodItem(name="Pizza", description="Cheesy pizza with toppings", price=9.99, category="Main Course", is_vegan=False)
pizza.add_item()
pizza.update_item(price=10.99, is_vegan=True)
print(f"ID: {pizza.get_id()}, Name: {pizza.name}, Price: {pizza.price}, Vegan: {pizza.is_vegan}")

# Create a beverage item
coffee = BeverageItem(name="Coffee", description="Hot coffee", price=2.99, category="Beverages", size="Large")
coffee.add_item()
coffee.update_item(size="Medium", price=3.49)
print(f"ID: {coffee.get_id()}, Name: {coffee.name}, Price: {coffee.price}, Size: {coffee.size}")

# Remove items
pizza.remove_item()
coffee.remove_item()

# Q.7.Write a code f0r Hotel Management System using OOPS .
# Create a Room class that has attributes such as room number, room type, rate, and availability (private).
# Implement methods to book a room, check in a guest, and check out a guest.
# Use encapsulation to hide the room's unique identification number.
# Inherit from the Room class to creat, a SuiteRoom class and a StandardRoom class, each with their own specific attributes and methods.

# Ans>>
# Base class for rooms
class Room:
    _next_id = 1  # Class variable for unique ID

    def __init__(self, room_number, room_type, rate):
        self.__id = Room._next_id
        Room._next_id += 1
        self.room_number = room_number
        self.room_type = room_type
        self.rate = rate
        self.__availability = True  # Private attribute

    def get_id(self):
        return self.__id

    def is_available(self):
        return self.__availability

    def book_room(self):
        if self.__availability:
            self.__availability = False
            print(f"Room {self.room_number} booked.")
        else:
            print(f"Room {self.room_number} is already booked.")

    def check_in(self):
        if not self.__availability:
            print(f"Guest checked into room {self.room_number}.")
        else:
            print(f"Room {self.room_number} is not booked yet.")

    def check_out(self):
        if not self.__availability:
            self.__availability = True
            print(f"Room {self.room_number} is now available.")
        else:
            print(f"Room {self.room_number} was not occupied.")

# Subclass for Suite Rooms
class SuiteRoom(Room):
    def __init__(self, room_number, rate, luxury_level):
        super().__init__(room_number, "Suite", rate)
        self.luxury_level = luxury_level

    def book_room(self):
        super().book_room()
        if not self.is_available():
            print(f"Enjoy your stay in the luxury level {self.luxury_level} suite.")

# Subclass for Standard Rooms
class StandardRoom(Room):
    def __init__(self, room_number, rate):
        super().__init__(room_number, "Standard", rate)

    def book_room(self):
        super().book_room()
        if not self.is_available():
            print(f"Enjoy your stay in our comfortable standard room.")

# Testing the system
# Create a suite room
suite = SuiteRoom(room_number=101, rate=200, luxury_level="Gold")
print(f"Room ID: {suite.get_id()}, Type: {suite.room_type}, Rate: ${suite.rate}")
suite.book_room()
suite.check_in()
suite.check_out()

# Create a standard room
standard = StandardRoom(room_number=102, rate=100)
print(f"\nRoom ID: {standard.get_id()}, Type: {standard.room_type}, Rate: ${standard.rate}")
standard.book_room()
standard.check_in()
standard.check_out()

# Q.8.Write a code f0r Fitness Club Management System using OOPS:
# Create a Member class that has attributes such as name , age , membership type , and membership status(private).
# Implement methods to register a new member, renew a membership, and cancel a membership.
# Use encapsulation to hide the memberes unique identification number.
# Inherit from the Member class to create a FamilyMember class and an IndividualMember classe each with their own specific attributes and methods.

# Ans>>
# Base class for members
class Member:
    _next_id = 1  # Class variable to generate unique IDs

    def __init__(self, name, age, membership_type):
        self.__id = Member._next_id
        Member._next_id += 1
        self.name = name
        self.age = age
        self.membership_type = membership_type
        self.__membership_status = 'Active'  # Private attribute

    def get_id(self):
        return self.__id

    def get_membership_status(self):
        return self.__membership_status

    def register_member(self):
        print(f"Member {self.name} with ID {self.__id} registered successfully.")

    def renew_membership(self):
        if self.__membership_status == 'Active':
            print(f"Membership for {self.name} is already active.")
        else:
            self.__membership_status = 'Active'
            print(f"Membership for {self.name} has been renewed.")

    def cancel_membership(self):
        if self.__membership_status == 'Inactive':
            print(f"Membership for {self.name} is already canceled.")
        else:
            self.__membership_status = 'Inactive'
            print(f"Membership for {self.name} has been canceled.")

# Subclass for family members
class FamilyMember(Member):
    def __init__(self, name, age, membership_type, family_size):
        super().__init__(name, age, membership_type)
        self.family_size = family_size

    def register_member(self):
        super().register_member()
        print(f"Family size for {self.name}'s membership: {self.family_size}")

# Subclass for individual members
class IndividualMember(Member):
    def __init__(self, name, age, membership_type):
        super().__init__(name, age, membership_type)

    def register_member(self):
        super().register_member()
        print(f"Individual member {self.name} registered.")

# Testing the system
# Create a family member
family_member = FamilyMember(name="John Doe", age=40, membership_type="Family", family_size=4)
family_member.register_member()
print(f"Membership Status: {family_member.get_membership_status()}")
family_member.renew_membership()
family_member.cancel_membership()

# Create an individual member
individual_member = IndividualMember(name="Jane Smith", age=30, membership_type="Individual")
individual_member.register_member()
print(f"\nMembership Status: {individual_member.get_membership_status()}")
individual_member.cancel_membership()
individual_member.renew_membership()

# Q.9.Write a code for Event Management System using OOPS:
# Create an Event class that has attributes such as name, date, time, location, and list of attendees (private).
# Implement methods to create a new event, add or remove attendeese and get the total number of attendees.
# Use encapsulation to hide the eventes unique identification number.
# Inherit from the Event class to create a PrivateEvent class and a PublicEvent classe each with their own specific attributes and methods.

# Ans>>
# Base class for events
class Event:
    _next_id = 1  # Class variable for unique ID generation

    def __init__(self, name, date, time, location):
        self.__id = Event._next_id
        Event._next_id += 1
        self.name = name
        self.date = date
        self.time = time
        self.location = location
        self.__attendees = []  # Private list of attendees

    def get_id(self):
        return self.__id

    def get_attendees(self):
        return self.__attendees

    def add_attendee(self, attendee):
        if attendee not in self.__attendees:
            self.__attendees.append(attendee)
            print(f"Attendee '{attendee}' added to event '{self.name}'.")
        else:
            print(f"Attendee '{attendee}' is already registered for event '{self.name}'.")

    def remove_attendee(self, attendee):
        if attendee in self.__attendees:
            self.__attendees.remove(attendee)
            print(f"Attendee '{attendee}' removed from event '{self.name}'.")
        else:
            print(f"Attendee '{attendee}' not found in event '{self.name}'.")

    def get_total_attendees(self):
        return len(self.__attendees)

# Subclass for private events
class PrivateEvent(Event):
    def __init__(self, name, date, time, location, host):
        super().__init__(name, date, time, location)
        self.host = host

    def add_attendee(self, attendee):
        if len(self.get_attendees()) < 20:  # Example limit for private events
            super().add_attendee(attendee)
        else:
            print(f"Cannot add '{attendee}'. Private event '{self.name}' is at capacity.")

# Subclass for public events
class PublicEvent(Event):
    def __init__(self, name, date, time, location, max_capacity):
        super().__init__(name, date, time, location)
        self.max_capacity = max_capacity

    def add_attendee(self, attendee):
        if len(self.get_attendees()) < self.max_capacity:
            super().add_attendee(attendee)
        else:
            print(f"Cannot add '{attendee}'. Public event '{self.name}' is at full capacity.")

# Testing the system
# Create a private event
private_event = PrivateEvent(name="Birthday Party", date="2023-08-01", time="18:00", location="John's House", host="John Doe")
private_event.add_attendee("Alice")
private_event.add_attendee("Bob")
print(f"Total attendees: {private_event.get_total_attendees()}")

# Create a public event
public_event = PublicEvent(name="Music Concert", date="2023-09-15", time="20:00", location="City Arena", max_capacity=100)
public_event.add_attendee("Charlie")
public_event.add_attendee("Dave")
public_event.add_attendee("Eve")
public_event.remove_attendee("Charlie")
print(f"\nTotal attendees: {public_event.get_total_attendees()}")

# Q10.Write a code for Airline Reservation System using OOPS:
# Create a Flight class that has attributes such as flight number, departur, and arrival airports, departur, and arrival times, and availabl, seats (private).
# Implement methods to book a seat, cancel a reservation, and get the remaining available seats.
# Use encapsulation to hide the flight's unique identification number.
# Inherit from the Flight class to create a DomesticFlight class and an InternationalFlight class, ,each with their

# Ans>>
# Base class for flights
class Flight:
    _next_id = 1  # Class variable for generating unique IDs

    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats):
        self.__id = Flight._next_id
        Flight._next_id += 1
        self.flight_number = flight_number
        self.departure_airport = departure_airport
        self.arrival_airport = arrival_airport
        self.departure_time = departure_time
        self.arrival_time = arrival_time
        self.__available_seats = total_seats  # Private attribute

    def get_id(self):
        return self.__id

    def get_available_seats(self):
        return self.__available_seats

    def book_seat(self):
        if self.__available_seats > 0:
            self.__available_seats -= 1
            print(f"Seat booked on flight {self.flight_number}. Seats remaining: {self.__available_seats}")
        else:
            print(f"No available seats on flight {self.flight_number}.")

    def cancel_reservation(self):
        self.__available_seats += 1
        print(f"Reservation canceled on flight {self.flight_number}. Seats remaining: {self.__available_seats}")

# Subclass for domestic flights
class DomesticFlight(Flight):
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats):
        super().__init__(flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats)

    # Additional methods or attributes specific to domestic flights can be added here

# Subclass for international flights
class InternationalFlight(Flight):
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats, international_code):
        super().__init__(flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats)
        self.international_code = international_code

    # Additional methods or attributes specific to international flights can be added here

# Testing the system
# Create a domestic flight
domestic_flight = DomesticFlight(
    flight_number="D123",
    departure_airport="JFK",
    arrival_airport="LAX",
    departure_time="2023-08-01 10:00",
    arrival_time="2023-08-01 13:00",
    total_seats=100
)

# Create an international flight
international_flight = InternationalFlight(
    flight_number="I456",
    departure_airport="JFK",
    arrival_airport="LHR",
    departure_time="2023-08-02 17:00",
    arrival_time="2023-08-03 06:00",
    total_seats=200,
    international_code="INTL456"
)

# Book seats on flights
domestic_flight.book_seat()
domestic_flight.book_seat()
domestic_flight.cancel_reservation()
print(f"Available seats on {domestic_flight.flight_number}: {domestic_flight.get_available_seats()}")

international_flight.book_seat()
international_flight.book_seat()
international_flight.cancel_reservation()
print(f"Available seats on {international_flight.flight_number}: {international_flight.get_available_seats()}")

# Q11. Define a Python module named constants.py containing constants like pi and the speed of light.
# Ans>>
PI = 3.141592653589793
SPEED_OF_LIGHT = 299792458
# from constants import PI, SPEED_OF_LIGHT

print(f"The value of pi is: {PI}")
print(f"The speed of light is: {SPEED_OF_LIGHT} m/s")

import math  # Import the correct math module

# Q.12. Write a Python module named calculator.py containing functions for addition, subtraction,multiplication, and division.
# Ans>
# calculator.py

def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b

def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero.")
    return a / b

add(55,56)
subtract(20,10)
multiply(5,5)

# Q Implement a Python package structure for a project named ecommerce, containing modules for product management and order processing.
# Ans>>
'''ecommerce/
    __init__.py
    products/
        __init__.py
        product.py
        inventory.py
    orders/
        __init__.py
        order.py
        payment.py'''

# Q14. Implement a Python module named string_utils.py containing functions for string manipulation, such as reversing and capitalizing strings.
# Ans>>
# string_utils.py

def reverse_string(s):
    return s[::-1]

def capitalize_string(s):
    return s.capitalize()

def to_uppercase(s):
    return s.upper()

def to_lowercase(s):
    return s.lower()

def remove_whitespace(s):
    return s.strip()

print(reverse_string("hello"))
print(capitalize_string("hello world"))
print(to_uppercase("hello"))
print(to_lowercase("HELLO"))
print(remove_whitespace("  hello  "))

# Q 15. Write a Python module named file_operations.py with functions for reading, writing, and appending data to a file.
# Ans>>
# file_operations.py

def read_file(file_path):
    with open(file_path, 'r') as file:
        content = file.read()
    return content

def write_file(file_path, data):
    with open(file_path, 'w') as file:
        file.write(data)

def append_to_file(file_path, data):
    with open(file_path, 'a') as file:
        file.write(data)


# from file_operations import read_file, write_file, append_to_file

# Write data to a file
write_file('example.txt', 'Hello, world!')

# Append data to the file
append_to_file('example.txt', '\nThis is an additional line.')

# Read data from the file
content = read_file('example.txt')
print(content)

# Q16. Write a Python program to create a text file named "employees.txt" and write the details of employees,including their name, age, and salary, into the file.
# Ans>>
# employees.py

def write_employee_details_to_file(file_path, employees):
    with open(file_path, 'w') as file:
        for employee in employees:
            name = employee['name']
            age = employee['age']
            salary = employee['salary']
            file.write(f"Name: {name}, Age: {age}, Salary: {salary}\n")

if __name__ == "__main__":
    # List of employee details
    employees = [
        {"name": "Alice Smith", "age": 30, "salary": 70000},
        {"name": "Bob Johnson", "age": 45, "salary": 85000},
        {"name": "Carol White", "age": 27, "salary": 65000},
        {"name": "David Brown", "age": 50, "salary": 95000}
    ]

    # File path to write the employee details
    file_path = "employees.txt"

    # Write employee details to the file
    write_employee_details_to_file(file_path, employees)

    print(f"Employee details have been written to {file_path}")

# Q17. Develop a Python script that opens an existing text file named "inventory.txt" in read mode and displays the contents of the file line by line.
# Ans>>
# read_inventory.py

def read_inventory(file_path):
    try:
        with open(file_path, 'r') as file:
            for line in file:
                print(line.strip())
    except FileNotFoundError:
        print(f"The file {file_path} does not exist.")
    except Exception as e:
        print(f"An error occurred while reading the file: {e}")

if __name__ == "__main__":
    # Path to the inventory file
    file_path = "inventory.txt"

    # Read and display the contents of the file
    read_inventory(file_path)

# Q 18. Create a Python script that reads a text file named "expenses.txt" and calculates the total amount spent on various expenses listed in the file.
# Ans>>
# calculate_expenses.py

def calculate_total_expenses(file_path):
    total_expenses = 0.0
    try:
        with open(file_path, 'r') as file:
            for line in file:
                try:
                    # Assuming each line contains an expense amount
                    expense = float(line.strip())
                    total_expenses += expense
                except ValueError:
                    print(f"Could not convert line to float: {line.strip()}")
    except FileNotFoundError:
        print(f"The file {file_path} does not exist.")
    except Exception as e:
        print(f"An error occurred while reading the file: {e}")

    return total_expenses

if __name__ == "__main__":
    # Path to the expenses file
    file_path = "expenses.txt"

    # Calculate the total expenses
    total = calculate_total_expenses(file_path)

    # Display the total expenses
    print(f"Total expenses: ${total:.2f}")

# Q 19. Create a Python program that reads a text file named "paragraph.txt" and counts the occurrences of each word in the paragraph, displaying the results in alphabetical order.
# Ans>>
# word_count.py

import string
from collections import Counter

def count_word_occurrences(file_path):
    try:
        with open(file_path, 'r') as file:
            # Read the content of the file
            text = file.read()

            # Convert text to lowercase and remove punctuation
            text = text.lower()
            text = text.translate(str.maketrans('', '', string.punctuation))

            # Tokenize the text into words
            words = text.split()

            # Count occurrences of each word
            word_counts = Counter(words)

            # Sort words alphabetically and display counts
            for word in sorted(word_counts):
                print(f"{word}: {word_counts[word]}")

    except FileNotFoundError:
        print(f"The file {file_path} does not exist.")
    except Exception as e:
        print(f"An error occurred while processing the file: {e}")

if __name__ == "__main__":
    # Path to the paragraph file
    file_path = "paragraph.txt"

    # Count word occurrences and display results
    count_word_occurrences(file_path)

